// Omni Context Graph — NanoGraph Schema
// Captures the physics of execution and value creation.
// 10 node types, 21 edge types.
//
// Demonstrates: enums, lists, Date, DateTime, Bool, F64,
//               @key, @unique, @index, edge properties

// ═══════════════════════════════════════════════════════════════
// POINTER NODES (Mutable)
// Updated in place. All carry: slug @key, createdAt, updatedAt, notes
// ═══════════════════════════════════════════════════════════════

node Client {
    slug: String @key
    name: String @unique
    status: enum(cold, dormant, focus, healthy, nurture)
    tags: [String]
    company: String?
    email: String?
    createdAt: DateTime
    updatedAt: DateTime
    notes: [String]?
}

node Actor {
    slug: String @key
    name: String @unique
    actorType: enum(agent, human)
    defaultChannel: String?
    createdAt: DateTime
    updatedAt: DateTime
    notes: [String]?
}

node Record {
    slug: String @key
    platform: enum(github, gmail, internal, mercury, other, slack, stripe)
    recordType: String
    externalId: String?
    uri: String?
    title: String?
    createdAt: DateTime
    updatedAt: DateTime
    notes: [String]?
}

node Opportunity {
    slug: String @key
    title: String @unique
    description: String?
    dealType: enum(expansion, net_new, retention, upsell)
    stage: enum(active, hold, identified, lost, proposal, qualifying, won)
    priority: enum(critical, high, low, medium)
    risk: enum(critical, high, low, medium)?
    amount: F64?
    currency: String?
    amountPaid: F64?
    discount: F64?
    expectedClose: DateTime?
    closedAt: DateTime?
    isRecurring: Bool?
    recurringInterval: String?
    createdAt: DateTime
    updatedAt: DateTime
    notes: [String]?
}

node Project {
    slug: String @key
    name: String @unique
    description: String?
    status: enum(active, completed, hold, support)
    engagementType: String?
    startDate: DateTime?
    expectedCompletion: DateTime?
    createdAt: DateTime
    updatedAt: DateTime
    notes: [String]?
}

node ActionItem {
    slug: String @key
    title: String @unique
    description: String?
    status: enum(blocked, cancelled, completed, in_progress, open)
    priority: enum(critical, high, low, medium)
    dueDate: DateTime?
    createdAt: DateTime
    updatedAt: DateTime
    notes: [String]?
}

// ═══════════════════════════════════════════════════════════════
// CLAIMS & EVENTS NODES (Append-Only)
// Never overwritten. Corrections use Supersedes.
// All carry: slug @key, createdAt (no updatedAt, no notes)
// ═══════════════════════════════════════════════════════════════

node Decision {
    slug: String @key
    decidedAt: DateTime
    intent: String
    status: enum(approved, cancelled, proposed, rejected)
    domain: enum(compliance, content, dev, finance, sales)
    assertion: enum(assumption, fact)
    confidence: enum(high, low, medium)?
    createdAt: DateTime
}

node Signal {
    slug: String @key
    observedAt: DateTime
    summary: String
    sentiment: enum(mixed, negative, neutral, positive)?
    urgency: enum(critical, high, low, medium)?
    sourceType: enum(call, email, meeting, message, observation, slack)
    assertion: enum(assumption, fact)
    confidence: enum(high, low, medium)?
    createdAt: DateTime
}

node Policy {
    slug: String @key
    policyKey: String @index
    name: String
    effectiveFrom: DateTime
    effectiveTo: DateTime?
    description: String
    tags: [String]?
    createdAt: DateTime
}

node Action {
    slug: String @key
    executedAt: DateTime
    operation: enum(create, delete, send, update)
    success: Bool
    errorMessage: String?
    resultSummary: String?
    payloadDiff: String?
    createdAt: DateTime
}

// ═══════════════════════════════════════════════════════════════
// CORE EDGES — Decision Spine
// ═══════════════════════════════════════════════════════════════

edge MadeBy: Decision -> Actor
edge DecisionAffects: Decision -> Client
edge SignalAffects: Signal -> Client

edge InformedBy: Decision -> Signal {
    influence: enum(minor, primary, supporting)
}

edge ScreenedBy: Decision -> Policy {
    outcome: enum(failed, not_applicable, overridden, passed)
    overrideReason: String?
}

edge ResultedIn: Decision -> Action

edge TouchedRecord: Action -> Record {
    touchAction: enum(created, deleted, mentioned, sent, updated)
    mutatedFields: [String]?
}

edge TouchedOpportunity: Action -> Opportunity {
    touchAction: enum(created, deleted, mentioned, sent, updated)
    mutatedFields: [String]?
}

edge SourcedFrom: Signal -> Record {
    extractionMethod: enum(llm, manual, rule)?
}

// ═══════════════════════════════════════════════════════════════
// VALUE LOOP EDGES
// ═══════════════════════════════════════════════════════════════

edge Surfaced: Signal -> Opportunity {
    confidence: enum(high, low, medium)
}

edge Targets: Decision -> Opportunity
edge DecisionGenerates: Decision -> ActionItem
edge AssignedTo: ActionItem -> Actor
edge Resolves: Action -> ActionItem

// ═══════════════════════════════════════════════════════════════
// VERSIONING & STRUCTURAL EDGES
// ═══════════════════════════════════════════════════════════════

edge BasedOnPrecedent: Decision -> Decision {
    similarity: enum(moderate, strong, weak)
}

edge Supersedes: Policy -> Policy {
    reason: String?
}

edge ClientOwnsRecord: Client -> Record
edge ClientOwnsOpportunity: Client -> Opportunity
edge ClientOwnsProject: Client -> Project
edge Contains: Opportunity -> Project
edge DerivedFrom: Record -> Policy
